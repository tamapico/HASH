#include <Windows.h>
#include <stdio.h>

// 参考
// ・LM Hash and NT Hash
// https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-samr/90ed76b0-9ae7-4842-938d-0d759998be3d


// PC1 : Permuted Choice 1
BYTE PC1[56] =
{
	57, 49, 41, 33, 25, 17, 9, 1,
	58, 50, 42, 34, 26, 18, 10, 2,
	59, 51, 43, 35, 27, 19, 11, 3,
	60, 52, 44, 36, 63, 55, 47, 39,
	31, 23, 15, 7, 62, 54, 46, 38,
	30, 22, 14, 6, 61, 53, 45, 37,
	29, 21, 13, 5, 28, 20, 12, 4
};

// PC2 : Permuted Choice 2
BYTE PC2[48] =
{
	14, 17, 11, 24, 1, 5, 3, 28,
	15, 6, 21, 10, 23, 19, 12, 4,
	26, 8, 16, 7, 27, 20, 13, 2,
	41, 52, 31, 37, 47, 55, 30, 40,
	51, 45, 33, 48, 44, 49, 39, 56,
	34, 53, 46, 42, 50, 36, 29, 32
};

BYTE NumLeftShifts[16] = { 1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1 };

// IP : initial permutation 
BYTE IP[64] =
{
	58, 50, 42, 34, 26, 18, 10, 2,
	60, 52, 44, 36, 28, 20, 12, 4,
	62, 54, 46, 38, 30, 22, 14, 6,
	64, 56, 48, 40, 32, 24, 16, 8,
	57, 49, 41, 33, 25, 17, 9, 1,
	59, 51, 43, 35, 27, 19, 11, 3,
	61, 53, 45, 37, 29, 21, 13, 5,
	63, 55, 47, 39, 31, 23, 15, 7
};

// IP^-1 : inverse initial permutation
BYTE InvIP[64] =
{
	40, 8, 48, 16, 56, 24, 64, 32,
	39, 7, 47, 15, 55, 23, 63, 31,
	38, 6, 46, 14, 54, 22, 62, 30,
	37, 5, 45, 13, 53, 21, 61, 29,
	36, 4, 44, 12, 52, 20, 60, 28,
	35, 3, 43, 11, 51, 19, 59, 27,
	34, 2, 42, 10, 50, 18, 58, 26,
	33, 1, 41, 9, 49, 17, 57, 25
};

BYTE E[48] =
{
	32, 1, 2, 3, 4, 5,
	4, 5, 6, 7, 8, 9,
	8, 9, 10, 11, 12, 13,
	12, 13, 14, 15, 16, 17,
	16, 17, 18, 19, 20, 21,
	20, 21, 22, 23, 24, 25,
	24, 25, 26, 27, 28, 29,
	28, 29, 30, 31, 32, 1
};

BYTE S[8][64] =
{
	{
		// S1
		14, 4, 13, 1, 2, 15, 11, 8, 3, 10, 6, 12, 5, 9, 0, 7,
		0, 15, 7, 4, 14, 2, 13, 1, 10, 6, 12, 11, 9, 5, 3, 8,
		4, 1, 14, 8, 13, 6, 2, 11, 15, 12, 9, 7, 3, 10, 5, 0,
		15, 12, 8, 2, 4, 9, 1, 7, 5, 11, 3, 14, 10, 0, 6, 13
	},
	{
		// S2
		15, 1, 8, 14, 6, 11, 3, 4, 9, 7, 2, 13, 12, 0, 5, 10,
		3, 13, 4, 7, 15, 2, 8, 14, 12, 0, 1, 10, 6, 9, 11, 5,
		0, 14, 7, 11, 10, 4, 13, 1, 5, 8, 12, 6, 9, 3, 2, 15,
		13, 8, 10, 1, 3, 15, 4, 2, 11, 6, 7, 12, 0, 5, 14, 9
	},
	{
		// S3
		10, 0, 9, 14, 6, 3, 15, 5, 1, 13, 12, 7, 11, 4, 2, 8,
		13, 7, 0, 9, 3, 4, 6, 10, 2, 8, 5, 14, 12, 11, 15, 1,
		13, 6, 4, 9, 8, 15, 3, 0, 11, 1, 2, 12, 5, 10, 14, 7,
		1, 10, 13, 0, 6, 9, 8, 7, 4, 15, 14, 3, 11, 5, 2, 12
	},
	{
		// S4
		7, 13, 14, 3, 0, 6, 9, 10, 1, 2, 8, 5, 11, 12, 4, 15,
		13, 8, 11, 5, 6, 15, 0, 3, 4, 7, 2, 12, 1, 10, 14, 9,
		10, 6, 9, 0, 12, 11, 7, 13, 15, 1, 3, 14, 5, 2, 8, 4,
		3, 15, 0, 6, 10, 1, 13, 8, 9, 4, 5, 11, 12, 7, 2, 14
	},
	{
		// S5
		2, 12, 4, 1, 7, 10, 11, 6, 8, 5, 3, 15, 13, 0, 14, 9,
		14, 11, 2, 12, 4, 7, 13, 1, 5, 0, 15, 10, 3, 9, 8, 6,
		4, 2, 1, 11, 10, 13, 7, 8, 15, 9, 12, 5, 6, 3, 0, 14,
		11, 8, 12, 7, 1, 14, 2, 13, 6, 15, 0, 9, 10, 4, 5, 3
	},
	{
		// S6
		12, 1, 10, 15, 9, 2, 6, 8, 0, 13, 3, 4, 14, 7, 5, 11,
		10, 15, 4, 2, 7, 12, 9, 5, 6, 1, 13, 14, 0, 11, 3, 8,
		9, 14, 15, 5, 2, 8, 12, 3, 7, 0, 4, 10, 1, 13, 11, 6,
		4, 3, 2, 12, 9, 5, 15, 10, 11, 14, 1, 7, 6, 0, 8, 13
	},
	{
		// S7
		4, 11, 2, 14, 15, 0, 8, 13, 3, 12, 9, 7, 5, 10, 6, 1,
		13, 0, 11, 7, 4, 9, 1, 10, 14, 3, 5, 12, 2, 15, 8, 6,
		1, 4, 11, 13, 12, 3, 7, 14, 10, 15, 6, 8, 0, 5, 9, 2,
		6, 11, 13, 8, 1, 4, 10, 7, 9, 5, 0, 15, 14, 2, 3, 12
	},
	{
		// S8
		13, 2, 8, 4, 6, 15, 11, 1, 10, 9, 3, 14, 5, 0, 12, 7,
		1, 15, 13, 8, 10, 3, 7, 4, 12, 5, 6, 11, 0, 14, 9, 2,
		7, 11, 4, 1, 9, 12, 14, 2, 0, 6, 10, 13, 15, 3, 5, 8,
		2, 1, 14, 7, 4, 10, 8, 13, 15, 12, 9, 0, 3, 5, 6, 11
	}
};

BYTE P[] =
{
	16, 7, 20, 21,
	29, 12, 28, 17,
	1, 15, 23, 26,
	5, 18, 31, 10,
	2, 8, 24, 14,
	32, 27, 3, 9,
	19, 13, 30, 6,
	22, 11, 4, 25
};

// Permutation 関数
// Permutation (転置) を行うための関数
// 転置とは、ビット位置に当たる数値を持つ N バイトのテーブルを用いて
// 入力データを別のバイト列に置き換える操作を言う
// 入力データの最も左のビットの位置を 1 とし、右に 2, 3, 4 ... と増えていく
// この操作を行うに当たって以下の条件がある
// 1.cbTable は 8 の倍数でなければならない
// 2.出力用バッファ out のサイズ (バイト数) は、 cbTable / 8 と一致しなければならない
// 3.入力用バッファ in のサイズ (バイト数) は、table 内の最大値 / 8 を越えてはならない
VOID WINAPI Permutation(BYTE* in, BYTE* table, DWORD cbTable, BYTE* out)
{
	BYTE byteTemp, bitTemp, bitIn, byteIn, bitOut, byteOut, i, j;

	for (i = 0; i < cbTable / 8; i++)
	{
		byteOut = 0;
		for (j = 0; j < 8; j++)
		{
			for (j = 0; j < 8; j++)
			{
				// 平文 8 バイト中の何バイト目か (0 〜 cbTable / 8)
				byteTemp = (table[i * 8 + j] - 1) / 8;
				// 1 バイト中の何ビット目か (0〜7)
				bitTemp = (table[i * 8 + j] - 1) % 8;
				byteIn = in[byteTemp];
				bitIn = (byteIn >> (7 - bitTemp)) & 1;

				bitOut = bitIn << (7 - j);
				byteOut |= bitOut;
			}
			// 結果を保存
			out[i] = byteOut;
		}
	}

	return;
}

VOID WINAPI Xor(BYTE* in1, BYTE* in2, DWORD cbIn, BYTE* out)
{
	DWORD i;

	for (i = 0; i < cbIn; i++)
	{
		out[i] = in1[i] ^ in2[i];
	}

	return;
}

// DesEncrypt 関数
// DES による暗号化を行う。DES による暗号化は以下の手順を経て行われる
// 1.入力データとして 64 ビットの平文と、64 ビットの暗号化鍵を受け取る
// 2.64 ビットの暗号化鍵を元に Permuted Choice 1 を行い 56 ビットの鍵 K0 を生成する
// 3.K0 のデータを 28 ビットのデータ C0, D0 の 2 つに分割する
// 4.C0, D0 のそれぞれを左ローテート (仕様書では左シフトと記載されているが、実際は左ローテート) して C1, D1 を作成する
// 5.C1, D1 のデータを元に Permuted Choice 2 を行い、48 ビットの鍵 K1 を生成する
// 6.C1, D1 〜 C16, D16 について 4. 及び 5. の処理を繰り返し K1〜K16を作成する
// 7.平文について Initial Permutation (IP) と呼ばれる初期転置を行う
// 8.初期転置を行った結果を 32 ビットのデータ L0, R0 の 2 つに分割する
// 9.R0 を 32 ビットから 48 ビットに拡張する
// 10.R0 をそのまま L1 とする
// 11 R0 を 48 ビットに拡張したものと K1 を入力データとして f 関数を呼び出し、その結果と L0 の論理積を R1 とする
// 12.L0, R0 〜 L15, R15 について 9. 〜 11. の処理を繰り返し L1, R1 〜 L16, R16 を作成する
// 13.R16, L16 (R16 が左で L16 が右) を元に Inverse Initial Permutation (最終転置) を行って、64 ビットの暗号化文を取得する
// 
// これを図にすると以下のようになる
// +---------------------------------+           +---------------------------------+
// | Plain Text (64 bits)            |           | Original Key (64 bits)          |
// +----------------+----------------+           +----------------+----------------+
//                  | Initial Permutation (IP)                    | Permuted Choice 1
//                  |                            +----------------+----------------+  +----------------+----------------+
// +----------------+----------------+           | Permuted Key K0 (56 bits)       +->+ C0 (上位28bits)| D0 (上位28bits)|
// | L0 (上位32bits)| R0 (下位32bits)|           +---------------------------------+  +--------+-------+-------+--------+
// +--------+-------+-------+--------+                                                         | 左ローテート  | 左ローテート
//          |               |                    +---------------------------------+  +--------+-------+-------+--------+
//          | +-------------+                    | Permuted Key K1 (48 bits)       +<-+ C1 (28 bits)   | D1 (28 bits)   |
//          |/      +-------+--------+           +----------------+----------------+  +--------+-------+-------+--------+
//         /|       | Expansion      |                            |         Permuted Choice 2  | 左ローテート  | 左ローテート            
//        / |       +-------+--------+     +----------------------+                            |               |
//       /  |               |              |     +---------------------------------+  +--------+-------+-------+--------+
//      /   |       +-------+--------+     |     | Permuted Key K2 (48 bits)       +<-+ C2 (28 bits)   | D2 (28 bits)   |
//      |   |       | f              +-----+     +----------------+----------------+  +--------+-------+-------+--------+
//      |   |       +-------+--------+                            |         Permuted Choice 2  | 左ローテート  | 左ローテート 
//      |  xor--------------+                                     :                            :               :
//      |   |                                                     :                            :               :
//      |   +---------------+
//      |                   |
// +----+-----------+-------+--------+
// | L1 (32bits)    | R1 (32bits)    |
// +--------+-------+-------+--------+
//          |               |
//          :               :
// +--------+-------+-------+--------+
// | L16 (32bits)   | R16 (32bits)   |
// +--------+-------+-------+--------+
//          |               |
//          +-------+-------+
//                  | Inverse Initial Permutation
// +---------------------------------+
// | Cipher Text (64 bits)           |
// +---------------------------------+
// 
VOID WINAPI DesEncrypt(BYTE* in, BYTE* OriginalKey, BYTE* out)
{
	BYTE i, j, temp[8];

	// Key Schedule 1 (KS1)
	// 与えられたオリジナルの鍵を元に 56 ビットの鍵 K0 を 1 個と、 48 ビットの鍵 16 個を作成する
	// +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
	// |01|02|03|04|05|06|07|08|09|10|11|12|13|14|15|16|17|18|19|20|21|22|23|24|25|26|27|28|29|30|31|32|33|34|35|36|37|38|39|40|41|42|43|44|45|46|47|48|49|50|51|52|53|54|55|56|
	// +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
	// | Permuted Key (56 bits)                                                                                                                                                |
	// +-----------------------------------------------------------------------------------+-----------------------------------------------------------------------------------+
	// | C0 (28 bits)                                                                      | D0 (28 bits)                                                                      |
	// +-----------------------------------------------------------------------------------+-----------------------------------------------------------------------------------+
	// C0, D0 についてそれぞれ 1 ビットローテートして C1, D1 を作成する
	//  +---------------------------------------------------------------------------------+  +--------------------------------------------------------------------------------+ 
	//  |                                                                                 |  |                                                                                |
	//  |                                                                                 v  |                                                                                v
	// +-----------------------------------------------------------------------------------+-----------------------------------------------------------------------------------+
	// | C1 (28 bits)                                                                      | D1 (28 bits)                                                                      |
	// +-----------------------------------------------------------------------------------+-----------------------------------------------------------------------------------+
	// 同じように C2, D2 については C1, D1 をそれぞれビットローテートして作成する
	// ローテートするビット数は、それぞれ 1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1
	BYTE C[17][4], D[17][4], K[17][7], KTemp[7];

	BYTE inIP[8], L[17][4], R[17][4], RExp[17][6], RXorK[17][6], Row, Column, SRet[4], PRet[4];

	// Permuted Choice 1
	Permutation(OriginalKey, PC1, 56, K[0]);

	// C0 : 56 ビットに縮小転置した K の上位 28 ビット
	memcpy(C[0], K[0], 4);
	C[0][3] &= 0xf0;

	// D0 : 56 ビットに縮小転置した K の下位 28 ビット
	memcpy(D[0], &K[0][3], 4);
	D[0][0] &= 0xf;

	for (i = 1; i < 17; i++)
	{
		// Cn は Cn-1 を NumLeftShifts[n - 1] ビット左ローテートしたもの
		for (j = 0; j < 4; j++)
		{
			C[i][j] = C[i - 1][j] << NumLeftShifts[i - 1];
			if (j < 3)
			{
				C[i][j] |= C[i - 1][j + 1] >> (8 - NumLeftShifts[i - 1]);
			}
		}
		C[i][3] |= (C[i - 1][0] >> (8 - NumLeftShifts[i - 1])) << 4;

		// Dn は Dn-1 を NumLeftShifts[n - 1] ビット左ローテートしたもの
		for (j = 0; j < 4; j++)
		{
			D[i][j] = D[i - 1][j] << NumLeftShifts[i - 1];
			if (j < 3)
			{
				D[i][j] |= D[i - 1][j + 1] >> (8 - NumLeftShifts[i - 1]);
			}
		}
		D[i][3] |= D[i - 1][0] >> (4 - NumLeftShifts[i - 1]);
		D[i][0] &= 0xf;

		// Cn と Dn から Kn を作成する

		memcpy(KTemp, C[i], 3);
		memcpy(&KTemp[4], &D[i][1], 3);
		KTemp[3] = C[i][3] | D[i][0];

		// Permuted Choice 2
		Permutation(KTemp, PC2, 48, K[i]);
		K[i][6] = 0;
	}

	// Initial Permutation
	Permutation(in, IP, 64, inIP);

	// 上位 32bit
	memcpy(L[0], inIP, 4);

	// 下位 32bit
	memcpy(R[0], &inIP[4], 4);

	for (i = 0; i < 16; i++)
	{
		// f : Feistel Structure 
		// Expansion
		Permutation(R[i], E, 48, RExp[i]);

		// Xor
		Xor(RExp[i], K[i + 1], 6, RXorK[i]);

		// S 関数
		// 48 ビットを 6 ビットずつの 8 個に分割し、bit1, bit6 の 2 進数 (00 〜 11 の4通り) を Row とする
		// bit2 〜 bit5 の 2 進数 (0000 〜 1111 の 16 通り) を Column とする
		// これを S1 〜 S8 のそれぞれのテーブルにあてはめ、4 ビットの 2進数値 (0000 〜 1111 の 16 通り) B1 〜 B8 の 32 ビットを取得する
		ZeroMemory(SRet, 4);
		for (j = 0; j < 8; j++)
		{
			Row = (RXorK[i][(j * 6) / 8] >> (7 - (j * 6) % 8)) & 1;
			Row <<= 1;
			Row |= (RXorK[i][(j * 6 + 5) / 8] >> (7 - (j * 6 + 5) % 8)) & 1;

			Column = (RXorK[i][(j * 6 + 1) / 8] >> (7 - (j * 6 + 1) % 8)) & 1;
			Column <<= 1;
			Column |= (RXorK[i][(j * 6 + 2) / 8] >> (7 - (j * 6 + 2) % 8)) & 1;
			Column <<= 1;
			Column |= (RXorK[i][(j * 6 + 3) / 8] >> (7 - (j * 6 + 3) % 8)) & 1;
			Column <<= 1;
			Column |= (RXorK[i][(j * 6 + 4) / 8] >> (7 - (j * 6 + 4) % 8)) & 1;

			SRet[j / 2] <<= 4;
			SRet[j / 2] |= S[j][Row * 16 + Column];
		}

		// P 関数
		// S 関数によって得られた結果を P テーブルにあてはめ 32 ビット→32 ビットの転置を行う
		Permutation(SRet, P, 32, PRet);

		// Ln と P 関数によって得られた結果を xor して Rn+1 を得る
		Xor(L[i], PRet, 4, R[i + 1]);

		// Rn はそのまま Ln+1 となる
		memcpy(L[i + 1], R[i], 4);
	}

	memcpy(temp, R[16], 4);
	memcpy(&temp[4], L[16], 4);

	// Final Permutation
	Permutation(temp, InvIP, 64, out);

	return;
}

VOID WINAPI LMHash(LPSTR lpIn, BYTE* Hash) // BYTE Hash[16]
{
	BYTE Data[14], InputKey[7], OutputKey[8], Encrypted[8];
	CHAR Message[] = "KGS!@#$%";
	DWORD i, cbIn, cbitsMessage = 64;

	for (cbIn = 0; lpIn[cbIn] != '\0'; cbIn++){}

	if (cbIn > 14)
	{
		return;
	}

	memset(Data, 0, 14);
	memcpy(Data, lpIn, cbIn);

	for (i = 0; i < cbIn; i++)
	{
		if (Data[i] >= 'a' && Data[i] <= 'z')
		{
			Data[i] -= 0x20; // 'a' - 'A'
		}
	}

	for (i = 0; i < 2; i++)
	{
		memcpy(InputKey, &Data[i * 7], 7);

		// Encrypting a 64-Bit Block with a 7-Byte Key
		OutputKey[0] = InputKey[0] & 0xfe;
		OutputKey[1] = ((InputKey[0] << 7) | (InputKey[1] >> 1)) & 0xfe;
		OutputKey[2] = ((InputKey[1] << 6) | (InputKey[2] >> 2)) & 0xfe;
		OutputKey[3] = ((InputKey[2] << 5) | (InputKey[3] >> 3)) & 0xfe;
		OutputKey[4] = ((InputKey[3] << 4) | (InputKey[4] >> 4)) & 0xfe;
		OutputKey[5] = ((InputKey[4] << 3) | (InputKey[5] >> 5)) & 0xfe;
		OutputKey[6] = ((InputKey[5] << 2) | (InputKey[6] >> 6)) & 0xfe;
		OutputKey[7] = InputKey[6] << 1;

		DesEncrypt((BYTE*)Message, OutputKey, Encrypted);

		if (Hash != NULL)
		{
			memcpy(&Hash[i * 8], Encrypted, 8);
		}
	}

	return;
}

INT main(INT argc, CHAR* argv[])
{
	// test suite:
	// LMHash("") = aad3b435b51404eeaad3b435b51404ee
	// LMHash("P@ssw0rd") = 921988BA001DC8E14A3B108F3FA6CB6D

	CHAR szPassword[] = "P@ssw0rd";
	BYTE Hash[16];

	LMHash(szPassword, Hash);

	return 0;
}